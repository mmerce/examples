(define ALL_ATTRS ["resource_type" "stat_pruning" "balance_objective"
                   "randomize" "node_threshold" "random_candidate_ratio"
                   "number_of_models" "bias" "c" "eps" "default_numeric_value"
                   "missing_numerics" "normalize" "regularization" "iterations"
                   "early_holdout" "early_out_of_bag" "learning_rate"
                   "step_out_of_bag"])

(define ATTRS_PER_TYPE {"model" ["stat_pruning" "balance_objective"
                                 "randomize" "node_threshold"]
                        "ensemble" ["random_candidate_ratio" "stat_pruning"
                                    "balance_objective" "number_of_models"
                                    "randomize" "node_threshold"]
                        "boosted-ensemble" ["stat_pruning" "balance_objective"
                                            "randomize" "node_threshold"]
                        "logisticregression" ["bias" "c" "eps"
                                              "default_numeric_value"
                                              "missing_numerics"
                                              "normalize" "regularization"]})

(define BOOSTING_PARAMS ["iterations" "early_holdout" "early_out_of_bag"
                         "learning_rate" "step_out_of_bag"])

(define (select-boosting-params amap)
  (let (assoc-param (lambda (m pname) (assoc m pname (amap pname))))
    (reduce assoc-param {} BOOSTING_PARAMS)))

;; Here's a custom generator for creating BigML models, ensembles,
;; boosted ensembles or logistic regressions.  For now, we've disabled
;; models and logistic regressions due to an external issue, but if
;; you comment in the uncommented lines and comment out as necessary
;; in the cond statement you should be able to re-enable them.
(define (params-generator model-types objective-type)
  (lambda ()
    (let (idx (floor (rand-range 0 (count model-types)))
          type (model-types idx)
          params (cond (= type "logisticregression")
                       (logistic-regression-params-generator)
                       (= type "ensemble")
                       (ensemble-params-generator objective-type)
                       (= type "model")
                       (model-params-generator objective-type)
                       (= type "boosted-ensemble")
                       (boosted-ensemble-params-generator objective-type)))
      (uniformize-params params))))

;; The smacdown primitive needs a homogeneous set of attributes
(define (uniformize-params params)
  (iterate (p params ap ALL_ATTRS)
    (if (not (contains? p ap)) (assoc p ap "N/A") p)))

;; Here's a custom generator for creating BigML models.
(define (model-params-generator objective-type)
  (let (max-trees 127
        max-nodes 1999
        regression (= "numeric" objective-type)
        cand {"resource_type" "model"
              "stat_pruning" (if (< (rand) 0.5) false true)
              "balance_objective" (if (or regression (< (rand) 0.5))
                                      false
                                      true)
              "randomize" true
              "node_threshold" (round (rand-range 4 max-nodes))})
    cand))

;; Here's a custom generator for creating BigML ensembles.  As
;; "random_candidate_ratio" tends towards 1, the ensemble becomes a
;; bag.
(define (ensemble-params-generator objective-type)
  (let (max-trees 127
        max-nodes 1999
        regression (= "numeric" objective-type)
        cand {"resource_type" "ensemble"
              "random_candidate_ratio" (rand)
              "stat_pruning" (if (< (rand) 0.5) false true)
              "balance_objective" (if (or regression (< (rand) 0.5)) false true)
              "number_of_models" (+ 1 (round (exp (* (log max-trees) (rand)))))
              "randomize" true
              "node_threshold" (round (rand-range 4 max-nodes))})
    cand))

;; Here's a custom generator for creating BigML logistic regressions.
(define (logistic-regression-params-generator)
  (let (max-c 256
        dnv-random (rand)
        default-numeric-value (cond (> dnv-random 0.8) "mean"
                                    (> dnv-random 0.6) "median"
                                    (> dnv-random 0.4) "minimum"
                                    (> dnv-random 0.2) "maximum"
                                    "zero")
        c (* max-c (rand))
        missing-numerics (if (< (rand) 0.5) false true)
        normalize (if (< (rand) 0.5) false true)
        regularization (if (< (rand) 0.5) "l1" "l2")
        bias (if (< (rand) 0.5) false true)
        eps (* (rand) 0.5)
        cand {"resource_type" "logisticregression"
              "bias" bias
              "c" c
              "eps" eps
              "default_numeric_value" default-numeric-value
              "missing_numerics" missing-numerics
              "normalize" normalize
              "regularization" regularization})
    cand))

;; Here's a custom generator for creating BigML boosted ensembles.
(define (boosted-ensemble-params-generator objective-type)
  (let (max-trees 127
        max-nodes 1999
        max-iterations 256
        regression (= "numeric" objective-type)
        cand {"resource_type" "boosted-ensemble"
              "stat_pruning" (if (< (rand) 0.5) false true)
              "balance_objective" (if (or regression (< (rand) 0.5))
                                      false
                                      true)
              "iterations" (round (rand-range 1 max-iterations))
              "early_holdout" (if (< (rand) 0.5) (rand-range 0.1 0.5) 0.0)
              "early_out_of_bag" (if (< (rand) 0.5) false true)
              "learning_rate" (rand-range 0.00001 0.9)
              "step_out_of_bag" (if (< (rand) 0.5) false true)
              "randomize" (if (< (rand) 0.5) false true)
              "node_threshold" (round (rand-range 4 max-nodes))})
    cand))


;; Filter the uniformized attributs to use the applicable to each resource type
(define (strict-params params)
  (let (type (params "resource_type")
        params (dissoc params "resource_type")
        attrs (ATTRS_PER_TYPE type []))
    (iterate (p params aa ALL_ATTRS)
      (if (member? aa attrs) p (dissoc p aa)))))

(define (params-for-resource params)
  (let (type (params "resource_type")
        res-params (strict-params params))
    (if (= type "boosted-ensemble")
      (let (bparams (select-boosting-params params))
        (assoc res-params "boosting" bparams))
      res-params)))

(define (train-general params)
  (let (type (params "resource_type")
        res-params (dissoc (params-for-resource params) "resource_type"))
    (create (if (= type "boosted-ensemble") "ensemble" type) res-params)))

(define (stats-for-class class per-class-stats)
  (some (lambda (c) (when (= class (c "class_name")) c)) per-class-stats))

(define (metric-from-eval metric ev)
  (let (met-matches (matches "(.*)->(.*)" metric)
        metric-value (if (empty? met-matches)
                       (ev ["result" "model" metric] false)
                       (let ([class class-met] (tail met-matches)
                             pcs (ev ["result" "model" "per_class_statistics"])
                             cstats (stats-for-class class pcs))
                         (cstats class-met))))
    (if (not (number? metric-value))
      (raise {"message" (str metric " is not a valid metric!")
              "code" -30})
      metric-value)))

;; This function takes a training and test set (and an objective field
;; id) and evaluates a set of parameters by training a logistic regression with
;; those parameters and performing an evaluation on them.  We decide
;; that phi is the metric we'd like to optimize, so we pull 1 - phi out
;; of each evaluation to return as the objective, as the algorithm
;; seeks to *minimize* a value and we want to *maximize* phi.
(define (smacdown-evaluator train test obj metric name)
  (lambda (params itr)
    (log-info "Evaluating " (count params) " candidates...")
    (let (train-params {"dataset" train
                        "objective_field" obj
                        "seed" "SMACdown"
                        "name" (str name " smacdown itr " itr " test model")}
          mod-fn (lambda (p) (merge p train-params))
          eval-fn (lambda (m) {"model" m "dataset" test})
          mod-params (map mod-fn params)
          mod-ids (map train-general mod-params)
          eval-ids (create* "evaluation" (map eval-fn mod-ids)))
      (log-info "Evaluation complete.")
      (map (lambda (eid) (- 1 (metric-from-eval metric (fetch (wait eid)))))
           eval-ids))))

;; Find optimal parameters using SMACdown
(define (find-optimal-parameters train-id
                                 test-id
                                 objective-id
                                 objective-type
                                 model-types)
  (let (eval-fn (smacdown-evaluator train-id
                                    test-id
                                    objective-id
                                    metric
                                    "smacdown-model")
        generator (params-generator model-types objective-type))
    (smacdown-optimize generator eval-fn "smacdown-model")))

(define (format-output output)
  (for (p output)
    (let (params (p "parameters")
          type (params "resource_type")
          res-params (dissoc (params-for-resource params) "resource_type"))
      (assoc {"parameters" res-params "resource_type" type}
             (str metric) (- 1 (p smacdown--actual))))))

;; Delete resources ignoring errors
(define (safe-delete id)
  (try (delete id)
       (catch e (log-info (str "Error deleting resource " id " ignored")))))

(define (delete-batchprediction-datasets resources)
  (for (r resources)
    (when (= (resource-type r) "batchprediction")
      (let (id ((fetch r) "output_dataset_resource" false))
        (when id (safe-delete id))))))

(define (get-datasets train-id validation-id test-id write)
  (let (treq {"origin_dataset" train-id
              "sample_rate" 0.85
              "replacement" false
              "seed" "SMACdown"}
        vreq (assoc treq "out_of_bag" true)
        [trid vid] (if (empty? validation-id)
                     (let (tset (create-dataset treq)
                           vset (create-dataset vreq)
                           _ (when write
                               (log-warn "No validation set specified")
                               (log-info "Created validation set is " vset)))
                       [tset vset])
                     (prog (when write
                             (log-info "Validation set is " validation-id))
                           [train-id validation-id]))
        tid (if (empty? test-id)
              (prog (when write
                      (log-warn "No test set specified; Using validation set"))
                    vid)
              (prog (when write (log-info "Test set is " test-id)) test-id)))
    (wait* [trid tid vid])))

(define (make-model-types objective-type
                          test-ensemble
                          test-boosting
                          test-model
                          test-logistic)
  (let (regression (= "numeric" objective-type)
        test-map {"ensemble" test-ensemble
                  "model" test-model
                  "boosted-ensemble" test-boosting
                  "logisticregression" (and test-logistic (not regression))})
    (reduce (lambda (v k) (if (test-map k) (cons k v) v)) [] (keys test-map))))

;; Take a dataset, create a training and test set, and find the
;; optimal parameters.  The function returns a list of parameters
;; ranked by objective.
(define (optimize-ensemble train-id
                           validation-id
                           test-id
                           objective-id
                           metric
                           test-ensemble
                           test-boosting
                           test-model
                           test-logistic)
  (let ([trid vid tid] (get-datasets train-id validation-id test-id true)
        obj-id (if (= objective-id "default")
                 (dataset-get-objective-id train-id)
                 objective-id)
        otype (or ((fetch train-id) ["fields" obj-id "optype"] false)
                  (raise {"message" (str "Invalid objective field")}))
        mtypes (make-model-types otype
                                 test-ensemble
                                 test-boosting
                                 test-model
                                 test-logistic)
        _ (log-info "Search over types: " (str mtypes))
        params (find-optimal-parameters trid tid obj-id otype mtypes)
        output-params (format-output params)
        _ (log-info "SMACdown search complete")
        _ (when delete-resources
            (log-info "Deleting intermediate resources...")
            (delete-batchprediction-datasets (created-resources))
            (map safe-delete (created-resources)))
        _ (log-info "Training model on full dataset...")
        mod-prms (merge ((head params) "parameters" {})
                        {"objective_field" obj-id
                         "name" "SMACdown Final Model"
                         "seed" "SMACdown"})
        [trid vid tid] (get-datasets train-id validation-id test-id false)
        full-mod (train-general (assoc mod-prms "dataset" train-id))
        best-mod (train-general (assoc mod-prms "dataset" trid))
        best-eval (create-evaluation best-mod tid)
        test-metric (metric-from-eval metric (fetch (wait best-eval))))
    (wait* [best-eval full-mod])
    (cons (assoc (head output-params)
                 "full_model" full-mod
                 "model" best-mod
                 (str metric " (test set)") test-metric
                 "evaluation" best-eval)
          (tail output-params))))

(define result
  (optimize-ensemble train-id
                     validation-id
                     test-id
                     objective-id
                     metric
                     test-ensemble
                     test-boosting
                     test-model
                     test-logistic))
